# Partie 4 : Autour de l'application

Dans cette derniÃ¨re partie, on va s'intÃ©resser toujours Ã  amÃ©liroer le niveau de sÃ©curitÃ© de l'application.  
Mais cette fois-ci en s'intÃ©ressant un peu plus Ã  ce qu'on peut faire Ã  l'extÃ©rieur du service.

## Sommaire

- [Partie 4 : Autour de l'application](#partie-4--autour-de-lapplication)
  - [Sommaire](#sommaire)
  - [1. Firewalling](#1-firewalling)
  - [2. ProtÃ©ger l'app contre le flood](#2-protÃ©ger-lapp-contre-le-flood)
  - [3. EmpÃªcher le programme de faire des actions indÃ©sirables](#3-empÃªcher-le-programme-de-faire-des-actions-indÃ©sirables)

## 1. Firewalling

**Le *firewall* permet de filtrer les connexions entrantes sur la machine, mais aussi les connexions sortantes.**

Une fois que notre serveur est en place, et qu'il hÃ©berge notre super service, il n'y Ã  priori que trÃ¨s peu de choses qu'on veut autoriser

- notre service doit accueillir les clients sur un port spÃ©cifique
- notre service SSH doit rester accessible sur le port 22

Ca sous-entend que toutes autres accÃ¨s rÃ©seau doit Ãªtre bloquÃ©, par exemple :

- des connexions entrantes sur d'autres ports
- n'importe quelle connexion sortante

> **Oui on bloque tout en sortie !** C'est une mesure de sÃ©curitÃ© simple et trÃ¨s forte. Seul inconvÃ©nient : il faudra dÃ©sactiver temporairement cette rÃ¨gle pour mettre Ã  jour le serveur quand c'est nÃ©cessaire (sinon il ne peut pas utiliser le rÃ©seau, pour tÃ©lÃ©charger des paquets par exemple).

ğŸŒ **Configurer de faÃ§on robuste le firewall**

- bloquer toutes les connexions sortantes
- bloquer toutes les connexions entrantes (y compris le ping) Ã  part si c'est Ã  destination du serveur SSH ou du service `efrei_admin`

ğŸŒ **Prouver que la configuration est effective**

- prouver que les connexions sortantes sont bloquÃ©es
- prouver que les pings sont bloquÃ©s, mais une connexion SSH fonctionne

![Firewall](./img/fw.jpg)

## 2. ProtÃ©ger l'app contre le flood

Fail2ban notre vieil ami ! Fail2ban est un outil classique sur les OS GNU/Linux.

**Le fonctionnement de fail2ban est simpliste :**

- on lui demande surveiller un fichier donnÃ©
- on dÃ©finit un pattern Ã  repÃ©rer dans ce fichier
- si plusieurs lignes correspondant au pattern se rÃ©pÃ¨tent, il effectue une action
- par exemple, on ajoute une rÃ¨gle firewall

> Quand on configure fail2ban pour surveiller un certain fichier, on dit qu'on crÃ©e une *jail* fail2ban.

**Cas concret ici :**

- dÃ¨s qu'un client se connecte Ã  notre service, une ligne de log est ajoutÃ© au fichier de log
- cette ligne de log contient l'IP du client qui s'est connectÃ©
- si un client se connecte + de 5 fois en moins de 10 secondes (par exemple) on peut estimer que c'est du flood (tentative de DOS ?)
- il faudrait blacklister automatiquement l'IP de ce client dans le firewall
- fail2ban fait exactement Ã§a

ğŸŒ **Installer fail2ban sur la machine**

ğŸŒ **Ajouter une *jail* fail2ban**

- elle doit lire le fichier de log du service, que vous avez normalement placÃ© dans `/var/log/`
- repÃ©rer la ligne de connexion d'un client
- blacklist Ã  l'aide du firewall l'IP de ce client

ğŸŒ **VÃ©rifier que Ã§a fonctionne !**

- faites-vous ban ! En faisant plein de connexions rapprochÃ©es avec le client
- constatez que le ban est effectif
- levez le ban (il y a une commande pour lever un ban qu'a rÃ©alisÃ© fail2ban)

## 3. EmpÃªcher le programme de faire des actions indÃ©sirables

Lors de son fonctionnement, un programme peut Ãªtre amenÃ© Ã  exÃ©cuter des **appels systÃ¨me** (ou *syscalls*) en anglais.  
Un programme **doit** exÃ©cuter un *syscall* dÃ¨s qu'il veut interagir avec une ressource du systÃ¨me. Par exemple :

- lire/modifier un fichier
- Ã©tablir une connexion rÃ©seau
- Ã©couter sur un port
- changer les droits d'un fichier
- obtenir la liste des processus
- lancer un nouveau processus
- etc.

âœ **ExÃ©cuter un *syscall* c'est demander au kernel de faire quelque chose.**

Ainsi, par exemple, quand on exÃ©cute la commande `cat` sur un fichier pour lire son contenu, **la commande `cat` va exÃ©cuter (entre autres) le *syscall* `open` afin de pouvoir ouvrir et lire le fichier**.

> Il se passe la mÃªme chose quand genre t'utilises Discord, et t'envoies un fichier Ã  un pote. L'application Discord va exÃ©cuter un *syscall* pour obtenir le contenu du fichier, et l'envoyer sur le rÃ©seau.

Si le programme est exÃ©cutÃ© par **un utilisateur qui a les droits sur ce fichier, alors le kernel autorisera ce *syscall*** et le programme `cat` pourra accÃ©der au contenu du fichier sans erreur, et l'afficher dans le terminal.

> Dit autrement : n'importe quel programme qui accÃ¨de au contenu d'un fichie (par exemple) exÃ©cute **forcÃ©ment** un *syscall* pour obtenir le contenu de ce fichier. Peu importe l'OS, c'est un truc commun Ã  tous.

âœ ***seccomp* est un outil qui permet de filtrer les *syscalls* qu'a le droit d'exÃ©cuter un programme**

On dÃ©finit une liste des *syscalls* que le programme a le droit de faire, les autres seront bloquÃ©s.

> Par exemple, un *syscall* sensible est `fork()` qui permet de crÃ©er un nouveau processus.

Dans notre cas, avec notre ptit *service*, c'est un des problÃ¨mes :

- vous injectez du code dans l'application en tant que vilain hacker
- pour exÃ©cuter des programmes comme `cat` ou autres
- Ã  chaque commande exÃ©cutÃ©e avec l'injection, un *syscall* est exÃ©cutÃ© par le programme serveur pour demander la crÃ©ation d'un nouveau processus (votre injection)
- on pourrait bloquer totalement ce comportement : empÃªcher le *service* de lancer un autre processus que `efrei_server`

ğŸŒ **Ajouter une politique seccomp au fichier `.service`**

- la politique doit Ãªtre la plus restrictive possible
- c'est Ã  dire que juste le strict minimum des *syscalls* nÃ©cessaires doit Ãªtre autorisÃ©

![seccomp](./img/exploit_seccomp.png)

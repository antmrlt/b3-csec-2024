# Partie 4 : Autour de l'application

üåû **Configurer de fa√ßon robuste le firewall**

```
firewall-cmd --permanent --new-policy myOutputPolicy

firewall-cmd --permanent --policy myOutputPolicy --add-ingress-zone HOST

firewall-cmd --permanent --policy myOutputPolicy --add-egress-zone ANY

firewall-cmd --permanent --policy myOutputPolicy --set-target DROP
```

üåû **Prouver que la configuration est effective**

```
[antna@localhost ~]$ sudo firewall-cmd --list-all
public (active)
  target: default
  icmp-block-inversion: no
  interfaces: enp0s3 enp0s8
  sources:
  services: ssh
  ports: 8888/tcp
  protocols:
  forward: yes
  masquerade: no
  forward-ports:
  source-ports:
  icmp-blocks:
  rich rules:
  ```

```
[antna@localhost ~]$ ping 1.1.1.1
PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.
^C
--- 1.1.1.1 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2079ms
```

## 2. Prot√©ger l'app contre le flood

üåû **Installer fail2ban sur la machine**

```
[antna@localhost ~]$ sudo systemctl start fail2ban
[antna@localhost ~]$ sudo systemctl status fail2ban
‚óè fail2ban.service - Fail2Ban Service
     Loaded: loaded (/usr/lib/systemd/system/fail2ban.service; disabled; preset: disabled)
     Active: active (running) since Tue 2024-09-10 11:21:06 EDT; 9s ago
       Docs: man:fail2ban(1)
    Process: 16388 ExecStartPre=/bin/mkdir -p /run/fail2ban (code=exited, status=0/SUCCESS)
   Main PID: 16389 (fail2ban-server)
      Tasks: 3 (limit: 11099)
     Memory: 14.2M
        CPU: 48ms
     CGroup: /system.slice/fail2ban.service
             ‚îî‚îÄ16389 /usr/bin/python3 -s /usr/bin/fail2ban-server -xf start

Sep 10 11:21:06 localhost.localdomain systemd[1]: Starting Fail2Ban Service...
Sep 10 11:21:06 localhost.localdomain systemd[1]: Started Fail2Ban Service.
Sep 10 11:21:06 localhost.localdomain fail2ban-server[16389]: Server ready
```

üåû **Ajouter une *jail* fail2ban**

- elle doit lire le fichier de log du service, que vous avez normalement plac√© dans `/var/log/`
- rep√©rer la ligne de connexion d'un client
- blacklist √† l'aide du firewall l'IP de ce client

Dans le fichier `/etc/fail2ban/jail.local` :
```
[efrei_server]
enabled = true
port    = 8888
filter  = efrei_server
logpath = /var/log/efreiapp/server.log
maxretry = 3
bantime = 3600
findtime = 600
```

Et dans le fichier ``/etc/fail2ban/filter.d/efrei_server.conf`
```
[Definition]
failregex = \[\d+\.\d+\] Received '.*' from \('<HOST>', \d+\)
ignoreregex =
```

üåû **V√©rifier que √ßa fonctionne !**

```
[antna@localhost ~]$ sudo fail2ban-client status efrei_server
Status for the jail: efrei_server
|- Filter
|  |- Currently failed: 1
|  |- Total failed:     38
|  `- File list:        /var/log/efreiapp/server.log
`- Actions
   |- Currently banned: 1
   |- Total banned:     1
   `- Banned IP list:   192.168.56.115
```

## 3. Emp√™cher le programme de faire des actions ind√©sirables

Lors de son fonctionnement, un programme peut √™tre amen√© √† ex√©cuter des **appels syst√®me** (ou *syscalls*) en anglais.  
Un programme **doit** ex√©cuter un *syscall* d√®s qu'il veut interagir avec une ressource du syst√®me. Par exemple :

- lire/modifier un fichier
- √©tablir une connexion r√©seau
- √©couter sur un port
- changer les droits d'un fichier
- obtenir la liste des processus
- lancer un nouveau processus
- etc.

‚ûú **Ex√©cuter un *syscall* c'est demander au kernel de faire quelque chose.**

Ainsi, par exemple, quand on ex√©cute la commande `cat` sur un fichier pour lire son contenu, **la commande `cat` va ex√©cuter (entre autres) le *syscall* `open` afin de pouvoir ouvrir et lire le fichier**.

> Il se passe la m√™me chose quand genre t'utilises Discord, et t'envoies un fichier √† un pote. L'application Discord va ex√©cuter un *syscall* pour obtenir le contenu du fichier, et l'envoyer sur le r√©seau.

Si le programme est ex√©cut√© par **un utilisateur qui a les droits sur ce fichier, alors le kernel autorisera ce *syscall*** et le programme `cat` pourra acc√©der au contenu du fichier sans erreur, et l'afficher dans le terminal.

> Dit autrement : n'importe quel programme qui acc√®de au contenu d'un fichie (par exemple) ex√©cute **forc√©ment** un *syscall* pour obtenir le contenu de ce fichier. Peu importe l'OS, c'est un truc commun √† tous.

‚ûú ***seccomp* est un outil qui permet de filtrer les *syscalls* qu'a le droit d'ex√©cuter un programme**

On d√©finit une liste des *syscalls* que le programme a le droit de faire, les autres seront bloqu√©s.

> Par exemple, un *syscall* sensible est `fork()` qui permet de cr√©er un nouveau processus.

Dans notre cas, avec notre ptit *service*, c'est un des probl√®mes :

- vous injectez du code dans l'application en tant que vilain hacker
- pour ex√©cuter des programmes comme `cat` ou autres
- √† chaque commande ex√©cut√©e avec l'injection, un *syscall* est ex√©cut√© par le programme serveur pour demander la cr√©ation d'un nouveau processus (votre injection)
- on pourrait bloquer totalement ce comportement : emp√™cher le *service* de lancer un autre processus que `efrei_server`

üåû **Ajouter une politique seccomp au fichier `.service`**

- la politique doit √™tre la plus restrictive possible
- c'est √† dire que juste le strict minimum des *syscalls* n√©cessaires doit √™tre autoris√©

![seccomp](./img/exploit_seccomp.png)
